use crypt::hash::Hasher;

pub use crypt::hkdf::{hkdf_expand, hkdf_extract};

#[allow(clippy::cast_possible_truncation)]
pub fn hkdf_expand_label<H: Hasher>(
    secret: &[u8],
    label: impl AsRef<str>,
    context: &[u8],
    length: u16,
) -> Box<[u8]> {
    let hkdf_label = {
        let mut x = Vec::new();

        x.extend(length.to_be_bytes());

        x.push(label.as_ref().len() as u8 + 6);
        x.extend(b"tls13 ");
        x.extend(label.as_ref().as_bytes());

        x.push(context.len() as u8);
        x.extend(context);

        x.into_boxed_slice()
    };

    hkdf_expand::<H>(secret, &hkdf_label, length as usize)
}

pub fn derive_secret<H: Hasher>(
    secret: &[u8],
    label: impl AsRef<str>,
    messages: &[u8],
) -> Box<[u8]> {
    let context = H::hash(messages);
    let length = context.len() as u16;

    hkdf_expand_label::<H>(secret, label, &context, length)
}

#[cfg(test)]
mod tests {
    use crypt::hash::sha::Sha384;
    use hex_literal::hex;

    use super::*;

    #[test]
    fn test_transcript() {
        let shared_secret =
            hex!("df4a291baa1eb7cfa6934b29b474baad2697e29f1f920dcc77c8a0a088447624");
        let transcript = [
            //
            // Client hello
            0x01, 0x00, 0x00, 0xf4, 0x03, 0x03, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
            0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0xe0, 0xe1, 0xe2,
            0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0,
            0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe,
            0xff, 0x00, 0x08, 0x13, 0x02, 0x13, 0x03, 0x13, 0x01, 0x00, 0xff, 0x01, 0x00, 0x00,
            0xa3, 0x00, 0x00, 0x00, 0x18, 0x00, 0x16, 0x00, 0x00, 0x13, 0x65, 0x78, 0x61, 0x6d,
            0x70, 0x6c, 0x65, 0x2e, 0x75, 0x6c, 0x66, 0x68, 0x65, 0x69, 0x6d, 0x2e, 0x6e, 0x65,
            0x74, 0x00, 0x0b, 0x00, 0x04, 0x03, 0x00, 0x01, 0x02, 0x00, 0x0a, 0x00, 0x16, 0x00,
            0x14, 0x00, 0x1d, 0x00, 0x17, 0x00, 0x1e, 0x00, 0x19, 0x00, 0x18, 0x01, 0x00, 0x01,
            0x01, 0x01, 0x02, 0x01, 0x03, 0x01, 0x04, 0x00, 0x23, 0x00, 0x00, 0x00, 0x16, 0x00,
            0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x1e, 0x00, 0x1c, 0x04, 0x03, 0x05,
            0x03, 0x06, 0x03, 0x08, 0x07, 0x08, 0x08, 0x08, 0x09, 0x08, 0x0a, 0x08, 0x0b, 0x08,
            0x04, 0x08, 0x05, 0x08, 0x06, 0x04, 0x01, 0x05, 0x01, 0x06, 0x01, 0x00, 0x2b, 0x00,
            0x03, 0x02, 0x03, 0x04, 0x00, 0x2d, 0x00, 0x02, 0x01, 0x01, 0x00, 0x33, 0x00, 0x26,
            0x00, 0x24, 0x00, 0x1d, 0x00, 0x20, 0x35, 0x80, 0x72, 0xd6, 0x36, 0x58, 0x80, 0xd1,
            0xae, 0xea, 0x32, 0x9a, 0xdf, 0x91, 0x21, 0x38, 0x38, 0x51, 0xed, 0x21, 0xa2, 0x8e,
            0x3b, 0x75, 0xe9, 0x65, 0xd0, 0xd2, 0xcd, 0x16, 0x62, 0x54,
            //
            // Server hello
            0x02, 0x00, 0x00, 0x76, 0x03, 0x03, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
            0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85,
            0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x20, 0xe0, 0xe1, 0xe2,
            0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0,
            0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe,
            0xff, 0x13, 0x02, 0x00, 0x00, 0x2e, 0x00, 0x2b, 0x00, 0x02, 0x03, 0x04, 0x00, 0x33,
            0x00, 0x24, 0x00, 0x1d, 0x00, 0x20, 0x9f, 0xd7, 0xad, 0x6d, 0xcf, 0xf4, 0x29, 0x8d,
            0xd3, 0xf9, 0x6d, 0x5b, 0x1b, 0x2a, 0xf9, 0x10, 0xa0, 0x53, 0x5b, 0x14, 0x88, 0xd7,
            0xf8, 0xfa, 0xbb, 0x34, 0x9a, 0x98, 0x28, 0x80, 0xb6, 0x15,
        ];
        let hello_hash = Sha384::hash(&transcript);
        assert_eq!(
            *hello_hash,
            hex!(
                "e05f64fcd082bdb0dce473adf669c2769f257a1c75a51b78
                 87468b5e0e7a7de4f4d34555112077f16e079019d5a845bd"
            )
        );

        let early_secret = hkdf_extract::<Sha384>(&[0], &[0; 48]);
        let empty_hash = Sha384::hash(&[]);

        let derived_secret = hkdf_expand_label::<Sha384>(&early_secret, "derived", &empty_hash, 48);
        println!("{derived_secret:02x?}");
        let handshake_secret = hkdf_extract::<Sha384>(&derived_secret, &shared_secret);
        assert_eq!(
            *handshake_secret,
            hex!(
                "bdbbe8757494bef20de932598294ea65b5e6bf6dc5c02a96
                 0a2de2eaa9b07c929078d2caa0936231c38d1725f179d299"
            )
        );

        let server_secret =
            hkdf_expand_label::<Sha384>(&handshake_secret, "s hs traffic", &hello_hash, 48);
        assert_eq!(
            *server_secret,
            hex!(
                "23323da031634b241dd37d61032b62a4f450584d1f7f4798
                 3ba2f7cc0cdcc39a68f481f2b019f9403a3051908a5d1622"
            )
        );

        let client_secret =
            hkdf_expand_label::<Sha384>(&handshake_secret, "c hs traffic", &hello_hash, 48);
        assert_eq!(
            *client_secret,
            hex!(
                "db89d2d6df0e84fed74a2288f8fd4d0959f790ff23946cdf
                 4c26d85e51bebd42ae184501972f8d30c4a3e4a3693d0ef0"
            )
        );

        let server_write_key = hkdf_expand_label::<Sha384>(&server_secret, "key", &[], 32);
        assert_eq!(
            *server_write_key,
            hex!("9f13575ce3f8cfc1df64a77ceaffe89700b492ad31b4fab01c4792be1b266b7f")
        );

        let server_write_iv = hkdf_expand_label::<Sha384>(&server_secret, "iv", &[], 12);
        assert_eq!(*server_write_iv, hex!("9563bc8b590f671f488d2da3"));

        let client_write_key = hkdf_expand_label::<Sha384>(&client_secret, "key", &[], 32);
        assert_eq!(
            *client_write_key,
            hex!("1135b4826a9a70257e5a391ad93093dfd7c4214812f493b3e3daae1eb2b1ac69")
        );

        let client_write_iv = hkdf_expand_label::<Sha384>(&client_secret, "iv", &[], 12);
        assert_eq!(*client_write_iv, hex!("4256d2e0e88babdd05eb2f27"));
    }
}
